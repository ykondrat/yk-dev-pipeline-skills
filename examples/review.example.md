# Code Review â€” URL Shortener API

> Generated by the code-review phase.

## Review Summary

| | |
|---|---|
| **Mode** | Full review (first pass) |
| **Verdict** | Approve with suggestions |
| **Files reviewed** | 18 |
| **Total findings** | 13 |

| Severity | Count |
|---|---|
| ðŸ”´ Critical | 0 |
| ðŸŸ¡ Major | 0 |
| ðŸ”µ Minor | 4 |
| âšª Nitpick | 7 |
| [DEBATABLE] | 2 |

## Automated Check Results

```
âœ… npx tsc --noEmit          â€” passed (0 errors)
âœ… npm run build              â€” passed
âœ… npm run lint               â€” passed (0 warnings)
âœ… npm test                   â€” passed (18/18 tests)
```

---

## Findings

### [CR-001] ðŸ”µ Minor â€” Missing timeout on redirect DB fallback
**File**: `src/domain/url/url.service.ts:47`
**Area**: Performance

The `resolve()` method falls back to a DB query when cache misses, but the Prisma
query has no explicit timeout. Under database load, this could make redirects hang.

```typescript
// Current
const url = await this.repo.findByShortCode(code);

// Suggested
const url = await withTimeout(this.repo.findByShortCode(code), 3000);
```

---

### [CR-002] ðŸ”µ Minor â€” Rate limiter doesn't clean up expired members
**File**: `src/api/middleware/rate-limiter.ts:32`
**Area**: Performance

The sliding window implementation adds members to the sorted set but only uses
`ZRANGEBYSCORE` to count. Old entries outside the window accumulate. Add
`ZREMRANGEBYSCORE` before counting.

```typescript
// Add cleanup before counting
await redis.zremrangebyscore(key, 0, windowStart);
const count = await redis.zcard(key);
```

---

### [CR-003] ðŸ”µ Minor â€” Click recording error not logged
**File**: `src/domain/analytics/analytics.service.ts:18`
**Area**: Error Handling

The fire-and-forget click recording uses `Promise.allSettled` but doesn't log rejected
promises. Silent failures make debugging impossible.

```typescript
// Current
void Promise.allSettled([
  this.repo.recordClick(clickData),
  this.urlRepo.incrementClickCount(urlId),
]);

// Suggested
void Promise.allSettled([
  this.repo.recordClick(clickData),
  this.urlRepo.incrementClickCount(urlId),
]).then((results) => {
  for (const r of results) {
    if (r.status === 'rejected') {
      this.logger.warn({ err: r.reason, urlId }, 'Click recording failed');
    }
  }
});
```

---

### [CR-004] ðŸ”µ Minor â€” Health check doesn't report degraded state
**File**: `src/api/routes/health.routes.ts:12`
**Area**: Logging & Observability

Health check returns 200 as long as the DB is connected, but doesn't check Redis.
If Redis is down, the API still works (graceful degradation) but monitoring won't know.

```typescript
// Suggested: include Redis status, return 200 but indicate degradation
const redis = await checkRedis();
const status = db && redis ? 'healthy' : 'degraded';
reply.status(db ? 200 : 503).send({ status, checks: { database: db, redis } });
```

---

### [CR-005] âšª Nitpick â€” Inconsistent import ordering
**Files**: `src/domain/url/url.service.ts`, `src/domain/analytics/analytics.service.ts`
**Area**: Code Style

External imports, internal imports, and type imports are mixed. Recommend consistent
ordering: external â†’ internal â†’ types, with blank lines between groups.

---

### [CR-006] âšª Nitpick â€” Magic number for short code length
**File**: `src/infrastructure/id-generator.ts:5`
**Area**: Code Style

```typescript
// Current
const code = nanoid(7);

// Suggested â€” extract constant
const SHORT_CODE_LENGTH = 7;
const code = nanoid(SHORT_CODE_LENGTH);
```

---

### [CR-007] âšª Nitpick â€” `BASE_URL` includes trailing slash inconsistency
**File**: `src/config/env.ts:15`
**Area**: Configuration

The `BASE_URL` env var is used as-is, but some code adds `/` before appending the
short code and some doesn't. Normalize by stripping trailing slash in the config.

```typescript
BASE_URL: z.string().url().transform((s) => s.replace(/\/+$/, '')),
```

---

### [CR-008] âšª Nitpick â€” `expiresAt` accepts past dates
**File**: `src/api/schemas/url.schema.ts:12`
**Area**: Correctness

The `expiresAt` field in the create URL schema validates it's a valid ISO date but
doesn't check it's in the future. A past expiration date would create an immediately
expired URL.

---

### [CR-009] âšª Nitpick â€” `DELETE` endpoint returns 204 without checking ownership
**File**: `src/api/routes/url.routes.ts:58`
**Area**: Security

Currently anyone can delete any URL. The spec doesn't mention auth, so this is by
design, but worth flagging: if auth is added later, this needs an ownership check.

---

### [CR-010] âšª Nitpick â€” Missing JSDoc on service public methods
**Files**: `src/domain/url/url.service.ts`, `src/domain/analytics/analytics.service.ts`
**Area**: Documentation

Public methods like `create()`, `resolve()`, `getAnalytics()` lack JSDoc. Since these
form the core API, documenting params and return types helps future maintainers.

---

### [CR-011] âšª Nitpick â€” Test factory for URLs doesn't randomize `shortCode`
**File**: `tests/factories.ts:18`
**Area**: Testing

```typescript
// Current â€” all factory URLs have same short code
export function buildUrl(overrides = {}) {
  return { shortCode: 'abc1234', ...overrides };
}

// Suggested
export function buildUrl(overrides = {}) {
  return { shortCode: nanoid(7), ...overrides };
}
```

---

### [CR-012] [DEBATABLE] â€” ioredis instead of node-redis
**File**: `src/infrastructure/cache.ts`
**Area**: Plan Compliance

The plan specified node-redis but implementation uses ioredis. The deviation is
documented in pipeline-state.json with rationale ("better TypeScript support").

**Case for**: ioredis has better TS types, cluster support, and is actively maintained.
**Case against**: node-redis is the official Redis client. Deviates from plan.

**Classification**: Justified improvement â€” ioredis is a reasonable choice.

---

### [CR-013] [DEBATABLE] â€” Nanoid over CUID2 for short codes
**File**: `src/infrastructure/id-generator.ts`
**Area**: Architecture

The plan didn't specify an ID generation strategy. Nanoid was chosen for its small
size and URL-safe alphabet. CUID2 would provide better collision resistance and
sortability but produces longer IDs (24 chars vs 7 chars).

**Case for nanoid**: Shorter URLs are the whole point. 7 chars is sufficient for the
expected scale.
**Case against**: CUID2 is more robust for unique IDs in distributed systems.

**Classification**: Acceptable trade-off for URL shortener use case.

---

## Cross-Step Impacts

None. No changes affect types, APIs, or schemas that downstream steps depend on.

## Next Steps

Findings are all Minor/Nitpick. Recommended to fix [CR-001] through [CR-004] before
testing. Nitpicks are optional but encouraged.

See `fix-plan.md` for the prioritized fix plan.
